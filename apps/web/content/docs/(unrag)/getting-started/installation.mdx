---
title: Installation
description: Run the CLI to install Unrag into your project and understand what gets created.
---

Installing Unrag is a one-command operation. You run the initializer, answer a few questions (or skip them with flags), and the CLI writes the necessary files into your project.

## Running the initializer

The simplest invocation is interactive:

```bash
bunx unrag@latest init
```

This will prompt you for:

1. **Install directory** — where to put the vendored module code. The default is `lib/unrag`, but you can choose any project-relative path that makes sense for your codebase structure.

2. **Store adapter** — which database adapter to use. Your options are Drizzle (a typed schema with Drizzle ORM), Prisma (using raw SQL through Prisma's client), or Raw SQL (using the `pg` driver directly).

3. **Import alias base** — the TypeScript path alias for importing Unrag. The default is `@unrag`, which means you'll import from `@unrag/core`, `@unrag/config`, etc. If you already have an `@unrag` alias or prefer something else, you can change it.

4. **Rich media ingestion** — whether to enable multimodal capabilities for PDFs, images, audio, video, and other files. If you say yes, the CLI presents a list of extractors to install (with sensible defaults pre-selected) and configures everything for you. This is optional—you can always enable it later by re-running `init --rich-media` or editing `unrag.config.ts` directly.

If you want to skip the prompts—useful in CI or when scripting—pass the `--yes` flag along with your choices:

```bash
bunx unrag@latest init --yes --store drizzle --dir lib/unrag --alias @unrag
```

To enable rich media non-interactively, add `--rich-media` (uses default extractors) or `--extractors` (with a comma-separated list):

```bash
bunx unrag@latest init --yes --store drizzle --rich-media
bunx unrag@latest init --yes --store drizzle --extractors pdf-text-layer,file-text
```

## What the CLI creates

After initialization completes, your project will have several new files:

<Files>
  <File name="unrag.config.ts" />
  <Folder name="lib/unrag" defaultOpen>
    <Folder name="core">
      <File name="index.ts" />
      <File name="context-engine.ts" />
      <File name="ingest.ts" />
      <File name="retrieve.ts" />
      <File name="chunking.ts" />
      <File name="types.ts" />
    </Folder>
    <Folder name="store">
      <File name="drizzle/" />
    </Folder>
    <Folder name="embedding">
      <File name="ai.ts" />
    </Folder>
    <File name="unrag.md" />
  </Folder>
  <File name="unrag.json" />
</Files>

If you enabled rich media during setup, you'll also see an `extractors/` folder containing the extractor modules you selected.

**`unrag.config.ts`** is where you configure the embedding provider, database connection, and default settings. The CLI generates this file with working code for your chosen adapter—you can use it immediately or customize it. If you enabled rich media, this file already has the extractors registered and the relevant `assetProcessing` flags enabled.

**`lib/unrag/`** contains the vendored module code including the core engine, your chosen store adapter, and the default embedding provider. These files are yours to read and modify.

**`lib/unrag/unrag.md`** contains setup documentation specific to your choices—the exact SQL schema, environment variables, and adapter notes.

**`unrag.json`** records your installation choices (including which extractors you installed) for future `unrag@latest init` runs.

## Changes to existing files

The CLI may also modify your existing configuration:

**Dependencies.** Unrag adds the packages needed for your chosen adapter to your `package.json`. For Drizzle, that includes `drizzle-orm` and `pg`. For Prisma, it adds `@prisma/client`. For Raw SQL, just `pg`. All adapters need the `ai` package for embedding. If these dependencies already exist, Unrag won't overwrite their versions.

**TypeScript paths.** If Unrag detects you're in a Next.js project, it patches your `tsconfig.json` (or `jsconfig.json`) to add path aliases:

```json
{
  "compilerOptions": {
    "paths": {
      "@unrag/*": ["./lib/unrag/*"],
      "@unrag/config": ["./unrag.config.ts"]
    }
  }
}
```

This lets you import Unrag modules cleanly without relative paths threading through your codebase.

## Automatic dependency installation

The CLI automatically runs your package manager to install dependencies after adding them to `package.json`. It detects which package manager you're using based on your lockfile (`bun.lock`, `pnpm-lock.yaml`, `yarn.lock`, or `package-lock.json`).

If you need to skip automatic installation (for example, in CI pipelines where you manage installs separately), pass the `--no-install` flag:

```bash
bunx unrag@latest init --yes --store drizzle --no-install
```

## Updating Unrag

Because Unrag vendors code into your project, "updating" means re-running the initializer. The CLI will ask before overwriting any existing files, so you can review changes before accepting them. A typical update workflow:

1. Run `bunx unrag@latest init` (it reads your previous choices from `unrag.json`)
2. Review the diff for any files the CLI wants to overwrite
3. Accept or reject file-by-file
4. Run your tests to make sure everything still works

This approach keeps you in control. You can see exactly what changed between versions, and you can choose to keep local modifications if they're intentional.

