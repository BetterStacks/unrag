---
title: Validating Your Installation
description: Use unrag doctor to verify your Unrag setup, database connectivity, and schema configuration.
---

After setting up Unrag, you might wonder whether everything is wired correctly. Is the database connection working? Are your environment variables set? Did you forget to add an index? The `unrag doctor` command answers these questions by running a comprehensive suite of checks against your installation.

## Why doctor exists

Unrag is vendored source code, which means you own it and can modify it. This flexibility comes with a trade-off: there's no central registry keeping track of what you've installed or whether it's configured correctly. You might add an extractor but forget to register it in your config. You might set up the database schema but miss an index that becomes important as your data grows.

Doctor scans your project and reports what it finds. It reads your `unrag.json`, examines your `unrag.config.ts`, checks your environment variables, and optionally connects to your database to verify the schema. The goal is to surface issues before they become production problems.

## Running the basic checks

The simplest invocation runs static checks—things that don't require a database connection:

```bash
bunx unrag doctor
```

This examines your project for:

**Installation integrity.** Does `unrag.json` exist and parse correctly? Is there a `unrag.config.ts` file? Does your install directory contain the expected folders (`core/`, `store/`, `embedding/`)?

**Environment variables.** Based on your embedding provider and store adapter, doctor checks whether the required environment variables are set. If you're using the default AI Gateway provider, it looks for `AI_GATEWAY_API_KEY`. If you're using the Drizzle adapter with Postgres, it looks for `DATABASE_URL`.

**Module presence.** If you've installed extractors or connectors, doctor verifies that the source files exist in the expected locations. A module directory without its main files suggests a partial installation.

**Config coherence.** Doctor performs static analysis on your `unrag.config.ts` to check whether installed extractors are actually registered and enabled. If you've installed `pdf-llm` but didn't add it to your extractors array, doctor warns you.

The output tells you what passed, what needs attention, and how to fix any issues. Passing checks show a checkmark; warnings show a caution symbol with suggested fixes.

## Checking the database

Static checks can only go so far. To verify that your database is correctly set up, add the `--db` flag:

```bash
bunx unrag doctor --db
```

This connects to your Postgres database and runs additional checks:

**Connectivity.** Can doctor establish a connection? It reports the PostgreSQL version, database name, and connected user.

**pgvector extension.** Is the vector extension installed and working? Doctor tests that the `<=>` operator works and checks for HNSW index support.

**Schema validation.** Do the expected tables exist (`documents`, `chunks`, `embeddings`)? Do they have the required columns? Are foreign key constraints configured with `ON DELETE CASCADE`?

**Index recommendations.** Doctor checks for btree indexes on `source_id` columns, which speed up filtering and deletes. It also checks for vector indexes on the embeddings table. For small datasets, sequential scan is fine—doctor only warns about missing vector indexes when you have more than 50,000 embeddings.

**Dimension consistency.** If you've switched embedding models at some point, you might have embeddings with different dimensions in the same database. Doctor detects this and warns you, because mixed dimensions can cause retrieval issues.

## Configuring doctor for your project

Every project is a little different. Maybe your database URL lives in a custom environment variable. Maybe you use a non-standard schema name. Maybe you want strict mode in CI but not locally.

The `doctor setup` command walks you through these options and generates a config file:

```bash
bunx unrag doctor setup
```

This interactive wizard asks about your setup and creates `.unrag/doctor.json` with your preferences. It also adds convenience scripts to your `package.json`:

```json
{
  "scripts": {
    "unrag:doctor": "unrag doctor --config .unrag/doctor.json",
    "unrag:doctor:db": "unrag doctor --config .unrag/doctor.json --db",
    "unrag:doctor:ci": "unrag doctor --config .unrag/doctor.json --db --strict --json"
  }
}
```

Now your team can run `npm run unrag:doctor` and get consistent results. The CI script adds `--strict` (treat warnings as failures) and `--json` (machine-readable output) for use in automated pipelines.

If you prefer non-interactive setup, pass `--yes` to use detected defaults:

```bash
bunx unrag doctor setup --yes
```

## The config file

The `.unrag/doctor.json` file stores your project-specific settings. It doesn't contain secrets—those stay in environment variables. Here's what the file looks like:

```json
{
  "version": 1,
  "installDir": "lib/unrag",
  "env": {
    "loadFiles": [".env", ".env.local"],
    "databaseUrlEnv": "DATABASE_URL"
  },
  "db": {
    "schema": "public",
    "tables": {
      "documents": "documents",
      "chunks": "chunks",
      "embeddings": "embeddings"
    }
  },
  "defaults": {
    "scope": null,
    "strict": false
  }
}
```

The `env.loadFiles` array controls which dotenv files doctor loads before running checks. The `env.databaseUrlEnv` field tells doctor which environment variable contains your database URL—useful if you've renamed it from the default `DATABASE_URL`.

The `db` section lets you specify a custom schema name or table names if you've customized the Drizzle schema. The `defaults` section sets default values for flags like `--strict`.

When you run `unrag doctor --config .unrag/doctor.json`, these settings are applied automatically. CLI flags still override config values, so you can always do `npm run unrag:doctor -- --strict` to add strict mode for a single run.

## Using doctor in CI

For continuous integration, you want machine-readable output and clear pass/fail semantics. The generated `unrag:doctor:ci` script handles this:

```bash
npm run unrag:doctor:ci
```

This runs with `--json` for structured output and `--strict` to fail on warnings. A typical GitHub Actions step looks like:

```yaml
- name: Validate Unrag setup
  run: npm run unrag:doctor:ci
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
    AI_GATEWAY_API_KEY: ${{ secrets.AI_GATEWAY_API_KEY }}
```

If doctor finds issues, the step fails and the JSON output tells you exactly what went wrong.

## Common issues and fixes

**Missing source_id indexes.** Doctor recommends btree indexes on `chunks.source_id` and `documents.source_id`. These speed up queries that filter by source and are essential for efficient prefix deletes. If you're using Drizzle, add indexes to your schema:

```ts
export const documents = pgTable(
  "documents",
  { /* columns */ },
  (t) => ({
    sourceIdIdx: index("documents_source_id_idx").on(t.sourceId),
  })
);
```

Or run the SQL directly:

```sql
CREATE INDEX IF NOT EXISTS documents_source_id_idx ON documents(source_id);
CREATE INDEX IF NOT EXISTS chunks_source_id_idx ON chunks(source_id);
```

**Extractor installed but not registered.** You ran `unrag add extractor pdf-llm` but didn't add it to your config. Doctor sees the files on disk but can't find the factory function in `unrag.config.ts`. Import the extractor and add it to the extractors array:

```ts
import { createPdfLlmExtractor } from "./lib/unrag/extractors/pdf-llm";

// In your config
engine: {
  extractors: [createPdfLlmExtractor()],
}
```

**DATABASE_URL not set.** Doctor looks in your environment and the dotenv files it loads. If you're storing the URL in a custom variable, either use `--database-url-env YOUR_VAR_NAME` or configure it in `.unrag/doctor.json` under `env.databaseUrlEnv`.

**Mixed embedding dimensions.** You changed embedding models at some point, and now your database contains vectors of different sizes. This causes retrieval errors because pgvector can't compare vectors of different dimensions. You'll need to re-ingest your content with the current model, or use the `--scope` flag to limit checks to a specific source prefix:

```bash
unrag doctor --db --scope "docs:"
```

This checks only embeddings for chunks whose `source_id` starts with "docs:".

## What doctor doesn't do

Doctor is a diagnostic tool, not a repair tool. It tells you what's wrong but doesn't automatically fix anything. This is intentional—database changes and file modifications should be deliberate actions you control.

Doctor also doesn't test your application's runtime behavior. It can verify that your config file exists and parses, but it doesn't actually call `engine.ingest()` or `engine.retrieve()`. If you want to verify the full pipeline works, write an integration test that ingests sample content and retrieves it.

## Next steps

<Cards>
  <Card title="Database Setup" href="/docs/getting-started/database">
    Create the schema and indexes doctor checks for
  </Card>
  <Card title="CLI Reference" href="/docs/reference/cli">
    Full list of doctor flags and options
  </Card>
</Cards>
