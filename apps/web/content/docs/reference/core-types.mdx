---
title: Core Types Reference
description: TypeScript types for the Unrag engine, inputs, outputs, and interfaces.
---

Unrag's type system is intentionally small. Understanding these types helps you work with the engine effectively and build custom components.

## IngestInput

The input to `engine.ingest()`:

```ts
type IngestInput = {
  sourceId: string;
  content: string;
  metadata?: Metadata;
  chunking?: { chunkSize?: number; chunkOverlap?: number };
};
```

<TypeTable
  type={{
    sourceId: {
      description:
        "Logical document identifier. Re-ingesting with the same sourceId replaces the previously stored content for that document (idempotent ingest).",
      type: 'string',
    },
    content: {
      description: 'The text to chunk and embed.',
      type: 'string',
    },
    metadata: {
      description: 'Optional JSON metadata stored with the document. Appears in retrieval results.',
      type: 'Metadata',
      default: '{}',
    },
    chunking: {
      description: 'Optional per-call chunking override (chunkSize, chunkOverlap).',
      type: 'object',
    },
  }}
/>

## IngestResult

The output from `engine.ingest()`:

```ts
type IngestResult = {
  documentId: string;
  chunkCount: number;
  embeddingModel: string;
  durations: { totalMs: number; chunkingMs: number; embeddingMs: number; storageMs: number };
};
```

<TypeTable
  type={{
    documentId: {
      description: 'UUID of the created/updated document.',
      type: 'string',
    },
    chunkCount: {
      description: 'How many chunks were created.',
      type: 'number',
    },
    embeddingModel: {
      description: 'Which model was used (e.g., "ai-sdk:openai/...").',
      type: 'string',
    },
    durations: {
      description: 'Timing breakdown: totalMs, chunkingMs, embeddingMs, storageMs. Useful for identifying bottlenecks.',
      type: 'object',
    },
  }}
/>

## RetrieveInput

The input to `engine.retrieve()`:

```ts
type RetrieveInput = {
  query: string;
  topK?: number;
  scope?: { sourceId?: string };
};
```

<TypeTable
  type={{
    query: {
      description: 'The search query to embed and find similar chunks.',
      type: 'string',
    },
    topK: {
      description: 'How many results to return.',
      type: 'number',
      default: '8',
    },
    scope: {
      description: 'Optional filtering. sourceId uses prefix matching (e.g., "docs:" matches all docs).',
      type: 'object',
    },
  }}
/>

## RetrieveResult

The output from `engine.retrieve()`:

```ts
type RetrieveResult = {
  chunks: Array<Chunk & { score: number }>;
  embeddingModel: string;
  durations: { totalMs: number; embeddingMs: number; retrievalMs: number };
};
```

<TypeTable
  type={{
    chunks: {
      description: 'Matching chunks with scores, ordered by score ascending (lower = more similar).',
      type: 'Array<Chunk & { score: number }>',
    },
    embeddingModel: {
      description: 'Which model embedded the query.',
      type: 'string',
    },
    durations: {
      description: 'Timing breakdown: totalMs, embeddingMs, retrievalMs.',
      type: 'object',
    },
  }}
/>

## Chunk

The chunk type represents a piece of a document:

```ts
type Chunk = {
  id: string;                 // UUID of the chunk
  documentId: string;         // UUID of the parent document
  sourceId: string;           // Logical identifier from ingestion
  index: number;              // Position in the original document (0, 1, 2, ...)
  content: string;            // The chunk's text
  tokenCount: number;         // Approximate token count
  metadata: Metadata;         // JSON metadata from ingestion
  embedding?: number[];       // Vector (present during upsert, not in query results)
  documentContent?: string;   // Full document text (during upsert only)
};
```

During retrieval, chunks include a `score` field representing similarity to the query.

## Metadata

Metadata is a flexible JSON object:

```ts
type MetadataValue = string | number | boolean | null;

type Metadata = Record<
  string,
  MetadataValue | MetadataValue[] | undefined
>;
```

Keep values simple and serializable. The adapter stores metadata as JSONB, so complex nested objects work but may be harder to query.

## EmbeddingProvider

The interface for embedding text into vectors:

```ts
type EmbeddingInput = {
  text: string;               // The text to embed
  metadata: Metadata;         // Context (from chunk or query)
  position: number;           // Chunk index (or 0 for queries)
  sourceId: string;           // Document sourceId (or "query")
  documentId: string;         // Document UUID (or "query")
};

type EmbeddingProvider = {
  name: string;               // Identifier for debugging
  dimensions?: number;        // Expected output size (optional)
  embed: (input: EmbeddingInput) => Promise<number[]>;
};
```

The `embed` function receives context about what's being embedded, though most implementations only use `text`. Return a numeric array representing the embedding vector.

## VectorStore

The interface for database operations:

```ts
type VectorStore = {
  upsert: (chunks: Chunk[]) => Promise<void>;
  query: (params: {
    embedding: number[];
    topK: number;
    scope?: { sourceId?: string };
  }) => Promise<Array<Chunk & { score: number }>>;
  delete: (input: DeleteInput) => Promise<void>;
};
```

The `upsert` method replaces stored content for the logical document identified by `chunks[0].sourceId` (exact match).

The `query` method finds the most similar chunks and returns them with similarity scores.

The `delete` method removes stored content by logical identity (either an exact `sourceId` or a namespace `sourceIdPrefix`).

## DeleteInput

The input to `engine.delete()` and `store.delete()`:

```ts
type DeleteInput =
  | { sourceId: string }
  | { sourceIdPrefix: string };
```

## ContextEngineConfig

The configuration for creating an engine:

```ts
type ContextEngineConfig = {
  embedding: EmbeddingProvider;
  store: VectorStore;
  defaults?: Partial<ChunkingOptions>;
  chunker?: Chunker;
  idGenerator?: () => string;
};

type ChunkingOptions = {
  chunkSize: number;
  chunkOverlap: number;
};

type Chunker = (content: string, options: ChunkingOptions) => ChunkText[];

type ChunkText = {
  index: number;
  content: string;
  tokenCount: number;
};
```

Most configurations only specify `embedding`, `store`, and `defaults`. Custom `chunker` and `idGenerator` are optional overrides for advanced use cases.

