---
title: unrag.config.ts Reference
description: The generated configuration file and how to customize it.
---

The `unrag.config.ts` file is the central place to configure Unrag. It's generated when you run `unrag init` and contains everything needed to construct a working engine: database connection, embedding provider, and default settings.

## Structure overview

A typical generated config looks like:

```ts
import { createContextEngine, defineConfig } from "./lib/unrag/core";
import { createAiEmbeddingProvider } from "./lib/unrag/embedding/ai";
import { createDrizzleVectorStore } from "./lib/unrag/store/drizzle";
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

export const unragConfig = {
  chunking: {
    chunkSize: 200,
    chunkOverlap: 40,
  },
  retrieval: {
    topK: 8,
  },
  embedding: {
    type: "text",
    model: "openai/text-embedding-3-small",
    timeoutMs: 15_000,
  },
  assetProcessing: {
    onUnsupportedAsset: "skip",
    onError: "skip",
    fetch: { enabled: true, maxBytes: 15 * 1024 * 1024, timeoutMs: 20_000 },
    pdf: {
      llmExtraction: {
        enabled: true, // template default (library default is false)
        model: "google/gemini-2.0-flash",
        prompt: "Extract all readable text from this PDF as faithfully as possible...",
        timeoutMs: 60_000,
        maxBytes: 15 * 1024 * 1024,
        maxOutputChars: 200_000,
      },
    },
  },
} as const;

export function createUnragEngine() {
  const embedding = createAiEmbeddingProvider({
    type: unragConfig.embedding.type,
    model: unragConfig.embedding.model,
    timeoutMs: unragConfig.embedding.timeoutMs,
  });

  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) throw new Error("DATABASE_URL is required");

  const pool = (globalThis as any).__unragPool ?? new Pool({ connectionString: databaseUrl });
  (globalThis as any).__unragPool = pool;

  const db = (globalThis as any).__unragDrizzleDb ?? drizzle(pool);
  (globalThis as any).__unragDrizzleDb = db;

  const store = createDrizzleVectorStore(db);

  return createContextEngine(
    defineConfig({
      embedding,
      store,
      assetProcessing: unragConfig.assetProcessing,
      defaults: unragConfig.chunking,
    })
  );
}

export async function retrieve(query: string) {
  const engine = createUnragEngine();
  return engine.retrieve({ query, topK: unragConfig.retrieval.topK });
}
```

## The unragConfig object

This object holds your default settings. Changing values here affects all operations that use these defaults.

### chunking

Controls how documents are split into chunks. See [Chunking](/docs/concepts/chunking) for details on strategies.

<TypeTable
  type={{
    chunkSize: {
      description: 'Approximate words per chunk. Smaller = more precise retrieval, higher embedding cost.',
      type: 'number',
      default: '200',
    },
    chunkOverlap: {
      description: 'Words that overlap between adjacent chunks. Preserves context across boundaries.',
      type: 'number',
      default: '40',
    },
  }}
/>

### retrieval

Default settings for `engine.retrieve()` calls.

<TypeTable
  type={{
    topK: {
      description: 'Default number of chunks returned. Can be overridden per-call.',
      type: 'number',
      default: '8',
    },
  }}
/>

### embedding

Configuration for the embedding provider. See [AI SDK Embeddings](/docs/embedding/ai-sdk) and [Multimodal Embeddings](/docs/embedding/multimodal-embeddings) for more.

<TypeTable
  type={{
    type: {
      description: 'Embedding mode. Use "multimodal" to embed images directly (requires compatible model).',
      type: '"text" | "multimodal"',
      default: '"text"',
    },
    model: {
      description: 'The embedding model identifier. Format: provider/model-name.',
      type: 'string',
      default: '"openai/text-embedding-3-small" (text) / "voyage/voyage-multimodal-3" (multimodal)',
    },
    timeoutMs: {
      description: 'Timeout for embedding API responses.',
      type: 'number',
      default: '15000',
    },
  }}
/>

### assetProcessing

Controls how PDFs, images, and other rich media are processed during ingestion. For complete type definitions, see [Asset Processing Reference](/docs/reference/asset-processing).

<TypeTable
  type={{
    onUnsupportedAsset: {
      description: 'What to do when an asset kind has no extractor (e.g., audio).',
      type: '"skip" | "fail"',
      default: '"skip"',
    },
    onError: {
      description: 'What to do when asset processing throws an error.',
      type: '"skip" | "fail"',
      default: '"skip"',
    },
    fetch: {
      description: 'URL fetching settings: enabled, maxBytes, timeoutMs, allowedHosts.',
      type: 'FetchConfig',
      typeDescriptionLink: '/docs/reference/asset-processing#fetchconfig',
    },
    "pdf.llmExtraction": {
      description: 'PDF text extraction via LLM. Key setting: enabled (template: true, library: false).',
      type: 'PdfLlmExtractionConfig',
      typeDescriptionLink: '/docs/reference/asset-processing#pdfllmextractionconfig',
    },
  }}
/>

<Callout>
The generated template sets `pdf.llmExtraction.enabled: true` so new projects work with PDFs out of the box. Set it to `false` if you want text-only ingestion or need to control costs.
</Callout>

## The createUnragEngine function

This function assembles all the pieces into a working engine. You'll typically call it at the start of your request handlers or scripts.

The generated version includes:

1. **Embedding provider creation** using your configured model and timeout
2. **Database connection** with a singleton pattern to prevent connection exhaustion
3. **Store adapter creation** using your chosen adapter type
4. **Engine construction** with everything wired together

## Customizing database connection

The generated code uses `globalThis` singletons for connection reuse. You can replace this with your own connection management:

```ts
// Use an existing pool from elsewhere in your app
import { pool } from "@/lib/db";
import { drizzle } from "drizzle-orm/node-postgres";

export function createUnragEngine() {
  const db = drizzle(pool);
  const store = createDrizzleVectorStore(db);
  
  // ... rest of function
}
```

For different database providers, adjust the connection setup:

<Tabs items={['Neon', 'Supabase', 'Standard Postgres']}>
<Tab value="Neon">
```ts
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";

const sql = neon(process.env.DATABASE_URL!);
const db = drizzle(sql);
```
</Tab>
<Tab value="Supabase">
```ts
import { Pool } from "pg";
const pool = new Pool({
  connectionString: process.env.SUPABASE_DB_URL,
});
```
</Tab>
<Tab value="Standard Postgres">
```ts
import { Pool } from "pg";
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
```
</Tab>
</Tabs>

## Adding custom helpers

Extend the config file with application-specific helpers:

```ts
// Tenant-scoped retrieval
export async function retrieveForTenant(tenantId: string, query: string) {
  const engine = createUnragEngine();
  return engine.retrieve({
    query,
    topK: unragConfig.retrieval.topK,
    scope: { sourceId: `tenant:${tenantId}:` },
  });
}

// Ingest with validation
export async function ingestDocument(
  sourceId: string,
  content: string,
  metadata: Record<string, unknown>
) {
  if (!sourceId || !content) {
    throw new Error("sourceId and content are required");
  }
  
  const engine = createUnragEngine();
  return engine.ingest({ sourceId, content, metadata });
}
```

## Environment variables

The config file expects these environment variables:

<TypeTable
  type={{
    DATABASE_URL: {
      description: 'Your Postgres connection string.',
      type: 'string',
      default: 'Required',
    },
    AI_GATEWAY_API_KEY: {
      description: 'API key for the embedding provider (typically OpenAI). Used by the AI SDK.',
      type: 'string',
      default: 'Required',
    },
    AI_GATEWAY_MODEL: {
      description: 'Override for the embedding model. Takes precedence over config file setting.',
      type: 'string',
      default: 'Optional',
    },
  }}
/>

## Server-only

Keep `unrag.config.ts` server-only. It imports database drivers, reads secrets from environment variables, and should never be bundled into client code. In Next.js, the file naturally stays server-side when imported only from Route Handlers and Server Actions.

