---
title: Installation
description: Run the CLI to install UnRAG into your project and understand what gets created.
---

Installing UnRAG is a one-command operation. You run the initializer, answer a few questions (or skip them with flags), and the CLI writes the necessary files into your project.

## Running the initializer

The simplest invocation is interactive:

```bash
bunx unrag init
```

This will prompt you for:

1. **Install directory** — where to put the vendored module code. The default is `lib/unrag`, but you can choose any project-relative path that makes sense for your codebase structure.

2. **Store adapter** — which database adapter to use. Your options are Drizzle (a typed schema with Drizzle ORM), Prisma (using raw SQL through Prisma's client), or Raw SQL (using the `pg` driver directly).

3. **Import alias base** — the TypeScript path alias for importing UnRAG. The default is `@unrag`, which means you'll import from `@unrag/core`, `@unrag/config`, etc. If you already have an `@unrag` alias or prefer something else, you can change it.

If you want to skip the prompts—useful in CI or when scripting—pass the `--yes` flag along with your choices:

```bash
bunx unrag init --yes --store drizzle --dir lib/unrag --alias @unrag
```

## What the CLI creates

After initialization completes, your project will have several new files:

<Files>
  <File name="unrag.config.ts" />
  <Folder name="lib/unrag" defaultOpen>
    <Folder name="core">
      <File name="index.ts" />
      <File name="context-engine.ts" />
      <File name="ingest.ts" />
      <File name="retrieve.ts" />
      <File name="chunking.ts" />
      <File name="types.ts" />
    </Folder>
    <Folder name="store">
      <File name="drizzle/" />
    </Folder>
    <Folder name="embedding">
      <File name="ai.ts" />
    </Folder>
    <File name="unrag.md" />
  </Folder>
  <File name="unrag.json" />
</Files>

**`unrag.config.ts`** is where you configure the embedding provider, database connection, and default settings. The CLI generates this file with working code for your chosen adapter—you can use it immediately or customize it.

**`lib/unrag/`** contains the vendored module code including the core engine, your chosen store adapter, and the default embedding provider. These files are yours to read and modify.

**`lib/unrag/unrag.md`** contains setup documentation specific to your choices—the exact SQL schema, environment variables, and adapter notes.

**`unrag.json`** records your installation choices for future `unrag init` runs.

## Changes to existing files

The CLI may also modify your existing configuration:

**Dependencies.** UnRAG adds the packages needed for your chosen adapter to your `package.json`. For Drizzle, that includes `drizzle-orm` and `pg`. For Prisma, it adds `@prisma/client`. For Raw SQL, just `pg`. All adapters need the `ai` package for embedding. If these dependencies already exist, UnRAG won't overwrite their versions.

**TypeScript paths.** If UnRAG detects you're in a Next.js project, it patches your `tsconfig.json` (or `jsconfig.json`) to add path aliases:

```json
{
  "compilerOptions": {
    "paths": {
      "@unrag/*": ["./lib/unrag/*"],
      "@unrag/config": ["./unrag.config.ts"]
    }
  }
}
```

This lets you import UnRAG modules cleanly without relative paths threading through your codebase.

## Installing dependencies

After the CLI finishes, install the new dependencies:

<Tabs items={['bun', 'npm', 'pnpm', 'yarn']}>
<Tab value="bun">
```bash
bun install
```
</Tab>
<Tab value="npm">
```bash
npm install
```
</Tab>
<Tab value="pnpm">
```bash
pnpm install
```
</Tab>
<Tab value="yarn">
```bash
yarn
```
</Tab>
</Tabs>

## Updating UnRAG

Because UnRAG vendors code into your project, "updating" means re-running the initializer. The CLI will ask before overwriting any existing files, so you can review changes before accepting them. A typical update workflow:

1. Run `bunx unrag init` (it reads your previous choices from `unrag.json`)
2. Review the diff for any files the CLI wants to overwrite
3. Accept or reject file-by-file
4. Run your tests to make sure everything still works

This approach keeps you in control. You can see exactly what changed between versions, and you can choose to keep local modifications if they're intentional.

